<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sandbox Elemental - Laboratorio de Part√≠culas</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&family=JetBrains+Mono:wght@400;600&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --bg-dark: #0a0e15;
            --bg-panel: #131920;
            --accent-cyan: #00fff2;
            --accent-magenta: #ff00aa;
            --accent-yellow: #ffeb3b;
            --text-primary: #e0e7ff;
            --text-secondary: #7a8aaa;
            --border-glow: rgba(0, 255, 242, 0.3);
        }
        
        body {
            font-family: 'JetBrains Mono', monospace;
            background: linear-gradient(135deg, var(--bg-dark) 0%, #1a1430 100%);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 242, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 242, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
            animation: gridMove 20s linear infinite;
        }
        
        @keyframes gridMove {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }
        
        header {
            background: var(--bg-panel);
            padding: 1.5rem 2rem;
            border-bottom: 2px solid var(--accent-cyan);
            box-shadow: 0 4px 20px rgba(0, 255, 242, 0.2);
            position: relative;
            z-index: 10;
        }
        
        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 0 0 30px rgba(0, 255, 242, 0.5);
            animation: titlePulse 3s ease-in-out infinite;
        }
        
        @keyframes titlePulse {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }
        
        .container {
            display: flex;
            flex: 1;
            gap: 1.5rem;
            padding: 1.5rem;
            position: relative;
            z-index: 1;
        }
        
        .sidebar {
            background: var(--bg-panel);
            border: 2px solid var(--accent-cyan);
            border-radius: 12px;
            padding: 1.5rem;
            width: 320px;
            box-shadow: 0 8px 32px rgba(0, 255, 242, 0.15);
            overflow-y: auto;
            max-height: calc(100vh - 150px);
        }
        
        .sidebar::-webkit-scrollbar {
            width: 8px;
        }
        
        .sidebar::-webkit-scrollbar-track {
            background: var(--bg-dark);
            border-radius: 4px;
        }
        
        .sidebar::-webkit-scrollbar-thumb {
            background: var(--accent-cyan);
            border-radius: 4px;
        }
        
        .material-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.8rem;
            margin-bottom: 1.5rem;
        }
        
        .material-btn {
            background: linear-gradient(135deg, var(--bg-dark), #1a1f2e);
            border: 2px solid transparent;
            border-radius: 8px;
            padding: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-primary);
        }
        
        .material-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, transparent, rgba(255, 255, 255, 0.1));
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .material-btn:hover::before {
            opacity: 1;
        }
        
        .material-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 242, 0.3);
        }
        
        .material-btn.active {
            border-color: var(--accent-cyan);
            box-shadow: 0 0 20px var(--border-glow), inset 0 0 20px rgba(0, 255, 242, 0.1);
            animation: activePulse 2s ease-in-out infinite;
        }
        
        @keyframes activePulse {
            0%, 100% { box-shadow: 0 0 20px var(--border-glow), inset 0 0 20px rgba(0, 255, 242, 0.1); }
            50% { box-shadow: 0 0 30px rgba(0, 255, 242, 0.5), inset 0 0 30px rgba(0, 255, 242, 0.2); }
        }
        
        .material-color {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            margin: 0 auto 0.5rem;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .controls {
            background: rgba(19, 25, 32, 0.8);
            border: 1px solid var(--accent-cyan);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        
        .control-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 0.5rem;
            display: block;
        }
        
        .btn-control {
            background: linear-gradient(135deg, var(--bg-dark), #1a1f2e);
            border: 2px solid var(--accent-magenta);
            color: var(--text-primary);
            padding: 0.7rem 1.2rem;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 0.85rem;
            text-transform: uppercase;
            width: 100%;
            margin-top: 0.5rem;
            transition: all 0.3s ease;
            letter-spacing: 1px;
        }
        
        .btn-control:hover {
            background: linear-gradient(135deg, #1a1f2e, var(--bg-dark));
            box-shadow: 0 4px 15px rgba(255, 0, 170, 0.4);
            transform: translateY(-1px);
        }
        
        .btn-control:active {
            transform: translateY(0);
        }
        
        .slider-container {
            margin-top: 1rem;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-magenta));
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent-yellow);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 235, 59, 0.6);
            border: 2px solid var(--bg-dark);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent-yellow);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 235, 59, 0.6);
            border: 2px solid var(--bg-dark);
        }
        
        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        canvas {
            border: 3px solid var(--accent-cyan);
            border-radius: 12px;
            box-shadow: 
                0 0 40px rgba(0, 255, 242, 0.4),
                0 0 80px rgba(255, 0, 170, 0.2);
            cursor: crosshair;
            background: #000000;
            animation: canvasGlow 4s ease-in-out infinite;
        }
        
        @keyframes canvasGlow {
            0%, 100% { 
                box-shadow: 
                    0 0 40px rgba(0, 255, 242, 0.4),
                    0 0 80px rgba(255, 0, 170, 0.2);
            }
            50% { 
                box-shadow: 
                    0 0 60px rgba(0, 255, 242, 0.6),
                    0 0 100px rgba(255, 0, 170, 0.3);
            }
        }
        
        .info-text {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
            line-height: 1.4;
        }
        
        .section-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--accent-cyan);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(0, 255, 242, 0.3);
        }
    </style>
</head>
<body>
    <header>
        <h1>‚öõ Sandbox Elemental ‚öõ</h1>
    </header>
    
    <div class="container">
        <aside class="sidebar">
            <div class="section-title">Materiales</div>
            <div class="material-grid" id="materialGrid"></div>
            
            <div class="controls">
                <div class="section-title">Controles</div>
                <label class="control-label">Tama√±o del Pincel</label>
                <div class="slider-container">
                    <input type="range" id="brushSize" min="1" max="20" value="5">
                    <div class="info-text">Tama√±o: <span id="brushValue">5</span>px</div>
                </div>
                
                <button class="btn-control" id="clearBtn">üóëÔ∏è Limpiar Todo</button>
                <button class="btn-control" id="pauseBtn">‚è∏Ô∏è Pausar</button>
                
                <div class="info-text" style="margin-top: 1rem;">
                    üí° Click y arrastra para dibujar<br>
                    üé® Experimenta con reacciones<br>
                    üí• Portal: Marco de obsidiana 4√ó3!
                </div>
            </div>
        </aside>
        
        <div class="canvas-container">
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const pixelSize = 2; // Tama√±o de cada part√≠cula en p√≠xeles de pantalla
        const width = 400; // Ancho en part√≠culas (800px / 2)
        const height = 300; // Alto en part√≠culas (600px / 2)
        
        // Grid de part√≠culas
        let grid = Array(height).fill(null).map(() => Array(width).fill(null));
        let selectedMaterial = 'sand';
        let brushSize = 5;
        let isDrawing = false;
        let isPaused = false;
        
        // Definici√≥n de materiales
        const MATERIALS = {
            sand: { name: 'Arena', color: '#f4a460', density: 1.5, type: 'powder' },
            water: { name: 'Agua', color: '#1e90ff', density: 1, type: 'liquid' },
            stone: { name: 'Piedra', color: '#696969', density: 10, type: 'solid' },
            fire: { name: 'Fuego', color: '#ff4500', density: 0.1, type: 'gas', life: 60 },
            ice: { name: 'Hielo', color: '#87ceeb', density: 0.9, type: 'solid' },
            lava: { name: 'Lava', color: '#ff4500', density: 2, type: 'liquid', hot: true },
            plant: { name: 'Planta', color: '#32cd32', density: 0.8, type: 'solid' },
            explosive: { name: 'C4', color: '#ffeb3b', density: 1, type: 'solid' },
            steam: { name: 'Vapor', color: '#f0f0f0', density: 0.05, type: 'gas', life: 120 },
            acid: { name: '√Åcido', color: '#adff2f', density: 1.2, type: 'liquid' },
            metal: { name: 'Metal', color: '#b8b8b8', density: 7, type: 'solid', conductive: true },
            oil: { name: 'Aceite', color: '#654321', density: 0.8, type: 'liquid', flammable: true },
            wood: { name: 'Madera', color: '#8b4513', density: 0.6, type: 'solid', flammable: true },
            gunpowder: { name: 'P√≥lvora', color: '#2f2f2f', density: 1.3, type: 'powder', explosive: true },
            petroleum: { name: 'Petr√≥leo', color: '#1a1a1a', density: 0.85, type: 'liquid', flammable: true },
            seed: { name: 'Semilla', color: '#a0522d', density: 1.2, type: 'powder' },
            glass: { name: 'Vidrio', color: '#e6f3ff', density: 2.5, type: 'solid' },
            smoke: { name: 'Humo', color: '#505050', density: 0.03, type: 'gas', life: 150 },
            salt: { name: 'Sal', color: '#ffffff', density: 2.1, type: 'powder' },
            concrete: { name: 'Hormig√≥n', color: '#888888', density: 2.4, type: 'solid', resistant: true },
            coal: { name: 'Carb√≥n', color: '#1c1c1c', density: 1.4, type: 'solid', flammable: true },
            obsidian: { name: 'Obsidiana', color: '#0f0820', density: 2.6, type: 'solid', portal: true },
            dirt: { name: 'Tierra', color: '#5c4033', density: 1.6, type: 'powder', fertile: true },
            methane: { name: 'Metano', color: '#90ee90', density: 0.02, type: 'gas', explosive: true, life: 200 },
            plasma: { name: 'Plasma', color: '#ff00ff', density: 0.08, type: 'gas', life: 80, hot: true },
            uranium: { name: 'Uranio', color: '#00ff00', density: 19, type: 'solid' },
            neutron: { name: 'Neutr√≥n', color: '#00ffff', density: 0.5, type: 'energy', life: 50 },
            electricity: { name: 'Electric', color: '#ffff00', density: 0, type: 'energy', life: 15 },
            concrete_powder: { name: 'P.Hormig√≥n', color: '#a9a9a9', density: 1.8, type: 'powder' },
            tnt: { name: 'TNT', color: '#ff0000', density: 1.5, type: 'solid', explosive: true },
            brick: { name: 'Ladrillo', color: '#b22222', density: 2.0, type: 'solid', resistant: true },
            clay: { name: 'Arcilla', color: '#b8860b', density: 1.7, type: 'powder' },
            portal: { name: 'Portal', color: '#8b00ff', density: 0, type: 'special' },
            mercury: { name: 'Mercurio', color: '#c0c0c0', density: 13.5, type: 'liquid', toxic: true }
        };
        
        // Inicializar interfaz
        function initUI() {
            const materialGrid = document.getElementById('materialGrid');
            
            Object.keys(MATERIALS).forEach(key => {
                const material = MATERIALS[key];
                const btn = document.createElement('button');
                btn.className = 'material-btn';
                btn.innerHTML = `
                    <div class="material-color" style="background: ${material.color}"></div>
                    <div>${material.name}</div>
                `;
                btn.onclick = () => {
                    document.querySelectorAll('.material-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    selectedMaterial = key;
                };
                materialGrid.appendChild(btn);
            });
            
            document.querySelector('.material-btn').classList.add('active');
            
            document.getElementById('brushSize').oninput = (e) => {
                brushSize = parseInt(e.target.value);
                document.getElementById('brushValue').textContent = brushSize;
            };
            
            document.getElementById('clearBtn').onclick = () => {
                grid = Array(height).fill(null).map(() => Array(width).fill(null));
            };
            
            document.getElementById('pauseBtn').onclick = function() {
                isPaused = !isPaused;
                this.textContent = isPaused ? '‚ñ∂Ô∏è Reanudar' : '‚è∏Ô∏è Pausar';
            };
        }
        
        // Funciones de movimiento b√°sicas
        function movePowder(x, y) {
            const particle = grid[y][x];
            if (!particle) return false;
            
            const speed = Math.min(Math.ceil(particle.density / 1.5), 3);
            
            // Intentar caer r√°pido
            for (let i = 1; i <= speed; i++) {
                if (y + i < height && !grid[y + i][x]) {
                    grid[y + i][x] = particle;
                    grid[y][x] = null;
                    return true;
                }
            }
            
            // Caer diagonal
            const dir = Math.random() < 0.5 ? -1 : 1;
            if (y < height - 1) {
                if (x + dir >= 0 && x + dir < width && !grid[y + 1][x + dir]) {
                    grid[y + 1][x + dir] = particle;
                    grid[y][x] = null;
                    return true;
                }
                if (x - dir >= 0 && x - dir < width && !grid[y + 1][x - dir]) {
                    grid[y + 1][x - dir] = particle;
                    grid[y][x] = null;
                    return true;
                }
            }
            return false;
        }
        
        function moveLiquid(x, y) {
            const particle = grid[y][x];
            if (!particle) return false;
            
            // Caer
            if (y < height - 1 && !grid[y + 1][x]) {
                grid[y + 1][x] = particle;
                grid[y][x] = null;
                return true;
            }
            
            // Moverse horizontalmente
            const dir = Math.random() < 0.5 ? -1 : 1;
            for (let i = 1; i <= 3; i++) {
                if (x + dir * i >= 0 && x + dir * i < width && !grid[y][x + dir * i]) {
                    grid[y][x + dir * i] = particle;
                    grid[y][x] = null;
                    return true;
                }
            }
            return false;
        }
        
        function moveGas(x, y, speed = 0.8) {
            const particle = grid[y][x];
            if (!particle) return false;
            
            if (y > 0 && Math.random() < speed) {
                const drift = Math.floor(Math.random() * 3) - 1;
                const nx = x + drift;
                if (nx >= 0 && nx < width && !grid[y - 1][nx]) {
                    grid[y - 1][nx] = particle;
                    grid[y][x] = null;
                    return true;
                }
            }
            return false;
        }
        
        // Funci√≥n de explosi√≥n OPTIMIZADA
        function explode(x, y, radius) {
            for (let dy = -radius; dy <= radius; dy += 2) {
                for (let dx = -radius; dx <= radius; dx += 2) {
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= radius) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            const intensity = 1 - dist / radius;
                            if (Math.random() < intensity * 0.8) {
                                if (dist < radius * 0.4) {
                                    grid[ny][nx] = { type: 'plasma', life: 60 };
                                } else {
                                    grid[ny][nx] = { type: 'fire', life: 50 };
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Sistema de actualizaci√≥n por tipo
        function updateParticle(x, y) {
            const particle = grid[y][x];
            if (!particle) return;
            
            const type = particle.type;
            const mat = MATERIALS[type];
            if (!mat) return;
            
            // Vida de part√≠culas temporales
            if (particle.life !== undefined) {
                particle.life--;
                if (particle.life <= 0) {
                    if (type === 'fire' || type === 'plasma') {
                        grid[y][x] = Math.random() < 0.3 ? { type: 'smoke', life: 100 } : null;
                    } else {
                        grid[y][x] = null;
                    }
                    return;
                }
            }
            
            // Movimiento b√°sico por tipo
            if (mat.type === 'powder') {
                movePowder(x, y);
            } else if (mat.type === 'liquid') {
                moveLiquid(x, y);
            } else if (mat.type === 'gas') {
                const speed = type === 'methane' ? 0.95 : (type === 'steam' ? 0.8 : 0.9);
                moveGas(x, y, speed);
            } else if (type === 'neutron') {
                // Neutrones se mueven r√°pido
                const vx = particle.vx || 1;
                const vy = particle.vy || 0;
                const nx = x + vx;
                const ny = y + vy;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height && !grid[ny][nx]) {
                    grid[ny][nx] = particle;
                    grid[y][x] = null;
                } else {
                    grid[y][x] = null;
                }
                return;
            }
            
            // Reacciones espec√≠ficas
            checkReactions(x, y);
        }
        
        // Sistema de reacciones OPTIMIZADO
        function checkReactions(x, y) {
            const particle = grid[y][x];
            if (!particle) return;
            
            const type = particle.type;
            
            // Revisar vecinos
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
                    
                    const neighbor = grid[ny][nx];
                    if (!neighbor) continue;
                    
                    // REACCIONES PRINCIPALES
                    
                    // Lava + Agua = Piedra + Vapor
                    if (type === 'lava' && neighbor.type === 'water') {
                        grid[y][x] = { type: 'stone' };
                        grid[ny][nx] = { type: 'steam', life: 100 };
                        // Efecto visual
                        for (let i = 0; i < 6; i++) {
                            const angle = (Math.PI * 2 * i) / 6;
                            const fx = Math.round(x + Math.cos(angle) * 2);
                            const fy = Math.round(y + Math.sin(angle) * 2);
                            if (fx >= 0 && fx < width && fy >= 0 && fy < height && !grid[fy][fx]) {
                                grid[fy][fx] = { type: 'steam', life: 80 };
                            }
                        }
                        return;
                    }
                    
                    // Fuego/Lava + Combustibles
                    if ((type === 'fire' || type === 'lava' || type === 'plasma') && Math.random() < 0.2) {
                        if (neighbor.type === 'oil' || neighbor.type === 'petroleum') {
                            grid[ny][nx] = { type: 'fire', life: 100 };
                        } else if (neighbor.type === 'wood' && !neighbor.burning) {
                            neighbor.burning = true;
                            neighbor.burnTime = 150;
                        } else if (neighbor.type === 'gunpowder') {
                            explode(nx, ny, 10);
                            return;
                        } else if (neighbor.type === 'plant') {
                            grid[ny][nx] = { type: 'fire', life: 50 };
                        } else if (neighbor.type === 'methane') {
                            explode(nx, ny, 15);
                            return;
                        } else if (neighbor.type === 'coal' && !neighbor.burning) {
                            neighbor.burning = true;
                            neighbor.burnTime = 300;
                        }
                    }
                    
                    // C4/TNT + Fuego/Lava/Electricidad
                    if ((type === 'explosive' || type === 'tnt') && 
                        (neighbor.type === 'fire' || neighbor.type === 'lava' || 
                         neighbor.type === 'electricity' || neighbor.type === 'plasma')) {
                        explode(x, y, type === 'tnt' ? 20 : 15);
                        return;
                    }
                    
                    // Hielo enfr√≠a
                    if (type === 'ice' && Math.random() < 0.02) {
                        if (neighbor.type === 'water') {
                            grid[ny][nx] = { type: 'ice' };
                            // Propagar congelaci√≥n
                            for (let dy2 = -1; dy2 <= 1; dy2++) {
                                for (let dx2 = -1; dx2 <= 1; dx2++) {
                                    const nx2 = nx + dx2;
                                    const ny2 = ny + dy2;
                                    if (nx2 >= 0 && nx2 < width && ny2 >= 0 && ny2 < height) {
                                        const n2 = grid[ny2][nx2];
                                        if (n2 && n2.type === 'water' && Math.random() < 0.2) {
                                            grid[ny2][nx2] = { type: 'ice' };
                                        }
                                    }
                                }
                            }
                        } else if (neighbor.type === 'fire' || neighbor.type === 'lava') {
                            grid[ny][nx] = { type: 'water' };
                        }
                    }
                    
                    // Semilla + Agua = Planta
                    if (type === 'seed' && neighbor.type === 'water' && Math.random() < 0.05) {
                        grid[y][x] = { type: 'plant', growth: 0 };
                        // Efecto visual
                        if (ny > 0 && !grid[y-1][x]) {
                            grid[y-1][x] = { type: 'plant', growth: 0 };
                        }
                        return;
                    }
                    
                    // Semilla + Tierra mojada = Planta r√°pido
                    if (type === 'seed' && neighbor.type === 'dirt' && neighbor.wet && Math.random() < 0.08) {
                        grid[y][x] = { type: 'plant', growth: 0 };
                        return;
                    }
                    
                    // Tierra absorbe agua (propaga absorci√≥n)
                    if (type === 'dirt' && neighbor.type === 'water' && !particle.wet && Math.random() < 0.1) {
                        particle.wet = true;
                        particle.color = '#3d2817';
                        grid[ny][nx] = null;
                        
                        // Propagar humedad a tierra cercana
                        for (let dy2 = -1; dy2 <= 1; dy2++) {
                            for (let dx2 = -1; dx2 <= 1; dx2++) {
                                const nx2 = x + dx2;
                                const ny2 = y + dy2;
                                if (nx2 >= 0 && nx2 < width && ny2 >= 0 && ny2 < height) {
                                    const n2 = grid[ny2][nx2];
                                    if (n2 && n2.type === 'dirt' && !n2.wet && Math.random() < 0.4) {
                                        n2.wet = true;
                                        n2.color = '#3d2817';
                                    }
                                }
                            }
                        }
                    }
                    
                    // Polvo hormig√≥n + Agua = Hormig√≥n (propaga en profundidad)
                    if (type === 'concrete_powder' && neighbor.type === 'water' && Math.random() < 0.3) {
                        grid[y][x] = { type: 'concrete' };
                        if (Math.random() < 0.5) grid[ny][nx] = null;
                        
                        // Propagar endurecimiento hacia abajo
                        for (let depth = 1; depth <= 5; depth++) {
                            if (y + depth >= height) break;
                            const below = grid[y + depth][x];
                            if (below && below.type === 'concrete_powder' && Math.random() < 0.4) {
                                grid[y + depth][x] = { type: 'concrete' };
                            } else {
                                break;
                            }
                        }
                        return;
                    }
                    
                    // Arcilla + Lava/Fuego = Ladrillo (propaga calor)
                    if (type === 'clay' && (neighbor.type === 'lava' || neighbor.type === 'fire' || neighbor.type === 'plasma') && 
                        Math.random() < 0.08) {
                        grid[y][x] = { type: 'brick' };
                        
                        // Propagar cocci√≥n a arcilla cercana
                        for (let dy2 = -2; dy2 <= 2; dy2++) {
                            for (let dx2 = -2; dx2 <= 2; dx2++) {
                                const nx2 = x + dx2;
                                const ny2 = y + dy2;
                                if (nx2 >= 0 && nx2 < width && ny2 >= 0 && ny2 < height) {
                                    const neighbor2 = grid[ny2][nx2];
                                    const dist = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                                    if (neighbor2 && neighbor2.type === 'clay' && 
                                        Math.random() < (0.3 / (dist + 1))) {
                                        grid[ny2][nx2] = { type: 'brick' };
                                    }
                                }
                            }
                        }
                        return;
                    }
                    
                    // Lava + Arena = Vidrio (propaga fusi√≥n)
                    if (type === 'lava' && neighbor.type === 'sand' && Math.random() < 0.08) {
                        grid[ny][nx] = { type: 'glass' };
                        // Propagar fusi√≥n de arena cercana
                        for (let dy2 = -1; dy2 <= 1; dy2++) {
                            for (let dx2 = -1; dx2 <= 1; dx2++) {
                                const nx2 = nx + dx2;
                                const ny2 = ny + dy2;
                                if (nx2 >= 0 && nx2 < width && ny2 >= 0 && ny2 < height) {
                                    const n2 = grid[ny2][nx2];
                                    if (n2 && n2.type === 'sand' && Math.random() < 0.3) {
                                        grid[ny2][nx2] = { type: 'glass' };
                                    }
                                }
                            }
                        }
                    }
                    
                    // Metal + Agua = √ìxido (muy lento, propaga oxidaci√≥n)
                    if (type === 'metal' && neighbor.type === 'water' && Math.random() < 0.002) {
                        grid[y][x] = { type: 'sand', color: '#b7410e' };
                        // Propagar oxidaci√≥n a metales cercanos
                        for (let dy2 = -1; dy2 <= 1; dy2++) {
                            for (let dx2 = -1; dx2 <= 1; dx2++) {
                                const nx2 = x + dx2;
                                const ny2 = y + dy2;
                                if (nx2 >= 0 && nx2 < width && ny2 >= 0 && ny2 < height) {
                                    const n2 = grid[ny2][nx2];
                                    if (n2 && n2.type === 'metal' && Math.random() < 0.1) {
                                        grid[ny2][nx2] = { type: 'sand', color: '#b7410e' };
                                    }
                                }
                            }
                        }
                    }
                    
                    // Mercurio + Metal
                    if (type === 'mercury' && neighbor.type === 'metal' && Math.random() < 0.03) {
                        grid[ny][nx] = { type: 'mercury' };
                    }
                    
                    // Uranio + Neutr√≥n = EXPLOSI√ìN
                    if (type === 'uranium' && neighbor.type === 'neutron' && Math.random() < 0.5) {
                        explode(x, y, 20);
                        // Crear m√°s neutrones
                        for (let i = 0; i < 8; i++) {
                            const angle = (Math.PI * 2 * i) / 8;
                            const fx = Math.round(x + Math.cos(angle) * 5);
                            const fy = Math.round(y + Math.sin(angle) * 5);
                            if (fx >= 0 && fx < width && fy >= 0 && fy < height) {
                                grid[fy][fx] = { type: 'neutron', life: 50, 
                                               vx: Math.round(Math.cos(angle) * 2), 
                                               vy: Math.round(Math.sin(angle) * 2) };
                            }
                        }
                        return;
                    }
                    
                    // Electricidad + Metal
                    if (type === 'electricity' && neighbor.conductive && Math.random() < 0.4) {
                        grid[ny][nx] = { type: 'electricity', life: 15 };
                    }
                    
                    // Portal teleport (OPTIMIZADO - solo 1 vez cada 10 frames)
                    if (type === 'portal' && Math.random() < 0.05 && 
                        neighbor.type !== 'portal' && neighbor.type !== 'obsidian') {
                        // Buscar otro portal (limitado a b√∫squeda cercana)
                        for (let py = Math.max(0, y - 100); py < Math.min(height, y + 100); py += 5) {
                            for (let px = Math.max(0, x - 100); px < Math.min(width, x + 100); px += 5) {
                                const p = grid[py][px];
                                if (p && p.type === 'portal' && (px !== x || py !== y)) {
                                    // Teleport
                                    for (let ty = -2; ty <= 2; ty++) {
                                        for (let tx = -2; tx <= 2; tx++) {
                                            const tpx = px + tx;
                                            const tpy = py + ty;
                                            if (tpx >= 0 && tpx < width && tpy >= 0 && tpy < height && !grid[tpy][tpx]) {
                                                grid[tpy][tpx] = neighbor;
                                                grid[ny][nx] = null;
                                                return;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Comportamientos especiales
            
            // Madera ardiendo
            if (type === 'wood' && particle.burning) {
                particle.burnTime = (particle.burnTime || 150) - 1;
                if (particle.burnTime <= 0) {
                    grid[y][x] = { type: 'fire', life: 30 };
                } else if (Math.random() < 0.1 && y > 0 && !grid[y-1][x]) {
                    grid[y-1][x] = { type: 'smoke', life: 120 };
                }
            }
            
            // Carb√≥n ardiendo
            if (type === 'coal' && particle.burning) {
                particle.burnTime = (particle.burnTime || 300) - 1;
                if (particle.burnTime <= 0) {
                    grid[y][x] = null;
                } else if (Math.random() < 0.15 && y > 0 && !grid[y-1][x]) {
                    grid[y-1][x] = { type: 'fire', life: 70 };
                }
            }
            
            // Plantas crecen
            if (type === 'plant' && Math.random() < 0.015) {
                particle.growth = (particle.growth || 0) + 1;
                if (particle.growth < 5) {
                    const dirs = [[0, -1], [-1, 0], [1, 0]];
                    const dir = dirs[Math.floor(Math.random() * dirs.length)];
                    const nx = x + dir[0];
                    const ny = y + dir[1];
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height && !grid[ny][nx]) {
                        grid[ny][nx] = { type: 'plant', growth: 0 };
                    }
                }
            }
            
            // Uranio emite neutrones
            if (type === 'uranium' && Math.random() < 0.01) {
                const angle = Math.random() * Math.PI * 2;
                const nx = Math.round(x + Math.cos(angle));
                const ny = Math.round(y + Math.sin(angle));
                if (nx >= 0 && nx < width && ny >= 0 && ny < height && !grid[ny][nx]) {
                    grid[ny][nx] = { type: 'neutron', life: 50, 
                                   vx: Math.round(Math.cos(angle) * 2), 
                                   vy: Math.round(Math.sin(angle) * 2) };
                }
            }
            
            // Obsidiana detecta portales (optimizado - cada 30 frames aprox)
            if (type === 'obsidian' && Math.random() < 0.003) {
                checkPortalFrame(x, y);
            }
        }
        
        // Detector de marco de portal
        function checkPortalFrame(x, y) {
            // Verificar si es esquina superior izquierda de un marco
            let valid = true;
            let w = 0, h = 0;
            
            // Detectar ancho
            for (let dx = 0; dx < 6 && x + dx < width; dx++) {
                const p = grid[y][x + dx];
                if (p && p.type === 'obsidian') {
                    w++;
                } else {
                    break;
                }
            }
            
            // Detectar alto
            for (let dy = 0; dy < 8 && y + dy < height; dy++) {
                const p = grid[y + dy][x];
                if (p && p.type === 'obsidian') {
                    h++;
                } else {
                    break;
                }
            }
            
            if (w >= 3 && h >= 4) {
                // Verificar marco completo
                // Verificar l√≠neas horizontales
                for (let dx = 0; dx < w; dx++) {
                    if (!grid[y][x + dx] || grid[y][x + dx].type !== 'obsidian') valid = false;
                    if (!grid[y + h - 1][x + dx] || grid[y + h - 1][x + dx].type !== 'obsidian') valid = false;
                }
                // Verificar l√≠neas verticales
                for (let dy = 0; dy < h; dy++) {
                    if (!grid[y + dy][x] || grid[y + dy][x].type !== 'obsidian') valid = false;
                    if (!grid[y + dy][x + w - 1] || grid[y + dy][x + w - 1].type !== 'obsidian') valid = false;
                }
                
                if (valid) {
                    // Crear portal
                    for (let dy = 1; dy < h - 1; dy++) {
                        for (let dx = 1; dx < w - 1; dx++) {
                            if (!grid[y + dy][x + dx]) {
                                grid[y + dy][x + dx] = { type: 'portal' };
                            }
                        }
                    }
                }
            }
        }
        
        // Dibujo
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            drawParticles(e);
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (isDrawing) drawParticles(e);
        });
        
        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
        });
        
        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
        });
        
        function drawParticles(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / pixelSize);
            const y = Math.floor((e.clientY - rect.top) / pixelSize);
            
            for (let dy = -brushSize; dy <= brushSize; dy++) {
                for (let dx = -brushSize; dx <= brushSize; dx++) {
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= brushSize) {
                        const px = x + dx;
                        const py = y + dy;
                        if (px >= 0 && px < width && py >= 0 && py < height && !grid[py][px]) {
                            grid[py][px] = { type: selectedMaterial };
                        }
                    }
                }
            }
        }
        
        // Loop principal
        let frameCount = 0;
        function update() {
            if (!isPaused) {
                frameCount++;
                // Actualizar de abajo hacia arriba
                const startX = frameCount % 2 === 0 ? 0 : width - 1;
                const endX = startX === 0 ? width : -1;
                const stepX = startX === 0 ? 1 : -1;
                
                for (let y = height - 1; y >= 0; y--) {
                    for (let x = startX; x !== endX; x += stepX) {
                        if (grid[y][x]) {
                            updateParticle(x, y);
                        }
                    }
                }
            }
            
            render();
            requestAnimationFrame(update);
        }
        
        function render() {
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const particle = grid[y][x];
                    if (particle) {
                        const mat = MATERIALS[particle.type];
                        if (mat) {
                            // Colores especiales
                            if (particle.color) {
                                ctx.fillStyle = particle.color;
                            } else if (particle.type === 'lava') {
                                const pulse = Math.sin(Date.now() / 200) * 0.2 + 0.8;
                                ctx.fillStyle = `rgb(${Math.floor(255 * pulse)}, ${Math.floor(69 * pulse)}, 0)`;
                            } else if (particle.type === 'plasma') {
                                const pulse = Math.sin(Date.now() / 100) * 0.5 + 0.5;
                                ctx.fillStyle = `rgb(${Math.floor(255 * pulse)}, 0, ${Math.floor(255 * (1-pulse))})`;
                            } else if (particle.type === 'portal') {
                                const pulse = Math.sin(Date.now() / 100) * 0.3 + 0.7;
                                ctx.fillStyle = `rgb(${Math.floor(139 * pulse)}, 0, ${Math.floor(255 * pulse)})`;
                            } else if (particle.type === 'uranium') {
                                const pulse = Math.sin(Date.now() / 300) * 0.3 + 0.7;
                                ctx.fillStyle = `rgb(0, ${Math.floor(255 * pulse)}, 0)`;
                            } else {
                                ctx.fillStyle = mat.color;
                            }
                            ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                        }
                    }
                }
            }
        }
        
        initUI();
        update();
    </script>
</body>
</html>
